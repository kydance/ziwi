package datetime

import (
	"fmt"
	"reflect"
	"testing"
	"time"
)

func TestNewDateTime(t *testing.T) {
	dt := NewDateTime()

	t.Run("NewDateTime", func(t *testing.T) {
		if dt == nil {
			t.Errorf("NewDateTime failed")
		}
	})
}
func TestNewDateTimeFromTime(t *testing.T) {
	tm := time.Now()

	type args struct {
		t time.Time
	}
	tests := []struct {
		name string
		args args
		want *DateTime
	}{
		{"1", args{tm}, NewDateTimeFromTime(tm)},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := NewDateTimeFromTime(tt.args.t); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("NewDateTimeFromTime() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestNewDateTimeFormStr(t *testing.T) {
	type args struct {
		str      string
		format   string
		timezone []string
	}
	tests := []struct {
		name    string
		args    args
		want    *DateTime
		wantErr bool
	}{
		{
			"1",
			args{"2024-09-10 23:24:25", "yyyy-mm-dd hh:mm:ss", []string{time.Local.String()}},
			NewDateTimeFromTime(time.Date(2024, 9, 10, 23, 24, 25, 0, time.Local)),
			false,
		},

		{
			"2",
			args{"2024-09-10", "yyyy-mm-dd", []string{time.Local.String()}},
			NewDateTimeFromTime(time.Date(2024, 9, 10, 0, 0, 0, 0, time.Local)),
			false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := NewDateTimeFormStr(tt.args.str, tt.args.format, tt.args.timezone...)
			if (err != nil) != tt.wantErr {
				t.Errorf("NewDateTimeFormStr() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("NewDateTimeFormStr() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_FormatTimeToStr(t *testing.T) {
	type args struct {
		format   string
		timezone []string
	}
	tests := []struct {
		name string
		args args
		want string
	}{
		{
			"1",
			args{
				"yyyy-mm-dd hh:mm:ss",
				nil,
			},
			time.Now().Format("2006-01-02 15:04:05"),
		},

		{
			"2",
			args{
				"yyyy-mm-dd hh:mm:ss",
				[]string{time.Local.String()},
			},
			time.Now().Format("2006-01-02 15:04:05"),
		},

		{
			"3",
			args{
				"yyyy-mm-dd",
				nil,
			},
			time.Now().Format("2006-01-02"),
		},

		{
			"4",
			args{
				"dd-mm-yy hh:mm:ss",
				nil,
			},
			time.Now().Format("02-01-06 15:04:05"),
		},

		{
			"5",
			args{
				"yyyy/mm/dd hh:mm:ss",
				nil,
			},
			time.Now().Format("2006/01/02 15:04:05"),
		},

		{
			"6",
			args{
				"yyyy/mm/dd hh:mm:ss",
				[]string{time.Local.String()},
			},
			time.Now().Format("2006/01/02 15:04:05"),
		},
	}

	pdt := NewDateTime()

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := pdt.FormatTimeToStr(tt.args.format, tt.args.timezone...); got != tt.want {
				t.Errorf("DateTime.FormatTimeToStr() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_AddMinute(t *testing.T) {
	tests := []struct {
		name   string
		minute int64
	}{
		{"1", 1},
		{"2", -1},
		{"3", 0},
	}

	pdt := NewDateTime()

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			pdt.AddMinute(tt.minute)
			fmt.Println(pdt.DateTimeStr())
		})
	}
}

func TestDateTime_AddHour(t *testing.T) {
	tests := []struct {
		name string
		hour int64
	}{
		{"1", 1},
		{"2", -1},
		{"3", 0},
		{"4", 48},
	}

	pdt := NewDateTime()

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			pdt.AddHour(tt.hour)
			fmt.Println(pdt.DateTimeStr())
		})
	}
}

func TestDateTime_AddDay(t *testing.T) {
	tests := []struct {
		name string
		day  int64
	}{
		{"1", 1},
		{"2", -1},
		{"3", 0},
	}

	pdt := NewDateTime()

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			pdt.AddDay(tt.day)
			fmt.Println(pdt.DateTimeStr())
		})
	}
}

func TestDateTime_AddYear(t *testing.T) {
	tests := []struct {
		name string
		year int64
	}{
		{"1", 1},
		{"2", -1},
		{"3", 0},
	}

	pdt := NewDateTime()

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			pdt.AddYear(tt.year)
			fmt.Println(pdt.DateTimeStr())
		})
	}
}

func TestDateTime_DateStr(t *testing.T) {
	dt, err := NewDateTimeFormStr("2024-09-10 23:24:25", "yyyy-mm-dd hh:mm:ss", time.Local.String())
	if err != nil {
		t.Errorf(err.Error())
	}

	tests := []struct {
		name string
		dt   *DateTime
		want string
	}{
		{"1", dt, "2024-09-10"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := dt.DateStr(); got != tt.want {
				t.Errorf("DateTime.DateStr() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_Date(t *testing.T) {
	dt, err := NewDateTimeFormStr("2024-09-10 23:24:25", "yyyy-mm-dd hh:mm:ss", time.Local.String())
	if err != nil {
		t.Errorf(err.Error())
	}

	tests := []struct {
		name  string
		dt    *DateTime
		want  int
		want1 time.Month
		want2 int
	}{
		{"1", dt, 2024, 9, 10},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, got1, got2 := tt.dt.Date()
			if got != tt.want {
				t.Errorf("DateTime.Date() got = %v, want %v", got, tt.want)
			}
			if got1 != tt.want1 {
				t.Errorf("DateTime.Date() got1 = %v, want %v", got1, tt.want1)
			}
			if got2 != tt.want2 {
				t.Errorf("DateTime.Date() got2 = %v, want %v", got2, tt.want2)
			}
		})
	}
}

func TestDateTime_TimeStr(t *testing.T) {
	tests := []struct {
		name string
		want string
	}{
		{"1", time.Now().Format("15:04:05")},
	}

	pdt := NewDateTime()

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := pdt.TimeStr(); got != tt.want {
				t.Errorf("DateTime.Time() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_DateTimeStr(t *testing.T) {
	tests := []struct {
		name string
		want string
	}{
		{"1", time.Now().Format(time.DateTime)},
	}

	pdt := NewDateTime()

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := pdt.DateTimeStr(); got != tt.want {
				t.Errorf("DateTime.DateTime() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_TodayStartTimeStr(t *testing.T) {
	tests := []struct {
		name string
		want string
	}{
		{"1", time.Now().Format("2006-01-02") + " 00:00:00"},
	}

	pdt := NewDateTime()

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := pdt.TodayStartTimeStr(); got != tt.want {
				t.Errorf("DateTime.TodayStartTIme() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_TodayEndTimeStr(t *testing.T) {
	tests := []struct {
		name string
		want string
	}{
		{"1", time.Now().Format("2006-01-02") + " 23:59:59"},
	}

	pdt := NewDateTime()

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := pdt.TodayEndTimeStr(); got != tt.want {
				t.Errorf("DateTime.TodayEndTime() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_Timestamp(t *testing.T) {
	tests := []struct {
		name string
		dt   *DateTime
		want int64
	}{
		{
			"1",
			func() *DateTime {
				dt, err := NewDateTimeFormStr("2024-09-10 23:24:25", "yyyy-mm-dd hh:mm:ss")
				if err != nil {
					t.Errorf(err.Error())
				}
				return dt
			}(),
			time.Date(2024, 9, 10, 23, 24, 25, 0, time.UTC).Unix(),
		},

		{
			"2",
			func() *DateTime {
				dt, err := NewDateTimeFormStr("2024-09-10 23:24:25", "yyyy-mm-dd hh:mm:ss", time.Local.String())
				if err != nil {
					t.Errorf(err.Error())
				}
				return dt
			}(),
			time.Date(2024, 9, 10, 23, 24, 25, 0, time.Local).Unix(),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.dt.Timestamp(time.Local.String()); got != tt.want {
				t.Errorf("DateTime.Timestamp() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_TimestampMilli(t *testing.T) {
	tests := []struct {
		name string
		dt   *DateTime
		want int64
	}{
		{
			"1",
			func() *DateTime {
				dt, err := NewDateTimeFormStr("2024-09-10 23:24:25", "yyyy-mm-dd hh:mm:ss")
				if err != nil {
					t.Errorf(err.Error())
				}
				return dt
			}(),
			time.Date(2024, 9, 10, 23, 24, 25, 0, time.UTC).UnixMilli(),
		},

		{
			"2",
			func() *DateTime {
				dt, err := NewDateTimeFormStr("2024-09-10 23:24:25", "yyyy-mm-dd hh:mm:ss", time.Local.String())
				if err != nil {
					t.Errorf(err.Error())
				}
				return dt
			}(),
			time.Date(2024, 9, 10, 23, 24, 25, 0, time.Local).UnixMilli(),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.dt.TimestampMilli(time.Local.String()); got != tt.want {
				t.Errorf("DateTime.TimestampMilli() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_TimestampMicro(t *testing.T) {
	tests := []struct {
		name string
		dt   *DateTime
		want int64
	}{
		{
			"1",
			func() *DateTime {
				dt, err := NewDateTimeFormStr("2024-09-10 23:24:25", "yyyy-mm-dd hh:mm:ss")
				if err != nil {
					t.Errorf(err.Error())
				}
				return dt
			}(),
			time.Date(2024, 9, 10, 23, 24, 25, 0, time.UTC).UnixMicro(),
		},

		{
			"2",
			func() *DateTime {
				dt, err := NewDateTimeFormStr("2024-09-10 23:24:25", "yyyy-mm-dd hh:mm:ss", time.Local.String())
				if err != nil {
					t.Errorf(err.Error())
				}
				return dt
			}(),
			time.Date(2024, 9, 10, 23, 24, 25, 0, time.Local).UnixMicro(),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.dt.TimestampMicro(time.Local.String()); got != tt.want {
				t.Errorf("DateTime.TimestampMicro() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_TimestampNano(t *testing.T) {
	tests := []struct {
		name string
		dt   *DateTime
		want int64
	}{
		{
			"1",
			func() *DateTime {
				dt, err := NewDateTimeFormStr("2024-09-10 23:24:25", "yyyy-mm-dd hh:mm:ss")
				if err != nil {
					t.Errorf(err.Error())
				}
				return dt
			}(),
			time.Date(2024, 9, 10, 23, 24, 25, 0, time.UTC).UnixNano(),
		},

		{
			"2",
			func() *DateTime {
				dt, err := NewDateTimeFormStr("2024-09-10 23:24:25", "yyyy-mm-dd hh:mm:ss", time.Local.String())
				if err != nil {
					t.Errorf(err.Error())
				}
				return dt
			}(),
			time.Date(2024, 9, 10, 23, 24, 25, 0, time.Local).UnixNano(),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.dt.TimestampNano(time.Local.String()); got != tt.want {
				t.Errorf("DateTime.TimestampNano() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_ZeroHourTimestamp(t *testing.T) {
	tests := []struct {
		name string
		want int64
	}{
		{
			"1",
			func() int64 {
				dt := time.Now().Format("2006-01-02")
				t, _ := time.Parse("2006-01-02", dt)
				return t.UTC().Unix() - 8*3600
			}(),
		},
	}

	pdt := NewDateTime()

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := pdt.ZeroHourTimestamp(); got != tt.want {
				t.Errorf("DateTime.ZeroHourTimestamp() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_NightTimestamp(t *testing.T) {
	tests := []struct {
		name string
		want int64
	}{
		{"1", func() int64 {
			dt := time.Now().Format("2006-01-02")
			t, _ := time.Parse("2006-01-02", dt)
			return t.UTC().Unix() - 8*3600 + 86400 - 1
		}()},
	}

	pdt := NewDateTime()

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := pdt.NightTimestamp(); got != tt.want {
				t.Errorf("DateTime.NightTimestamp() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_BeginOfMinute(t *testing.T) {
	tests := []struct {
		name string
		dt   *DateTime
		want time.Time
	}{
		{
			"general",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.UTC)},
			time.Date(2024, 9, 11, 10, 23, 0, 0, time.UTC),
		},
		{
			"different location",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.FixedZone("CST", 8*3600))},
			time.Date(2024, 9, 11, 10, 23, 0, 0, time.FixedZone("CST", 8*3600)),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.dt.BeginOfMinute(); !got.Equal(tt.want) {
				t.Errorf("DateTime.BeginOfMinute() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_EndOfMinute(t *testing.T) {
	tests := []struct {
		name string
		dt   *DateTime
		want time.Time
	}{
		{
			"general",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.UTC)},
			time.Date(2024, 9, 11, 10, 23, 59, int(time.Second-time.Nanosecond), time.UTC),
		},
		{
			"different location",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.FixedZone("CST", 8*3600))},
			time.Date(2024, 9, 11, 10, 23, 59, int(time.Second-time.Nanosecond), time.FixedZone("CST", 8*3600)),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.dt.EndOfMinute(); !got.Equal(tt.want) {
				t.Errorf("DateTime.EndOfMinute() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_BeginOfHour(t *testing.T) {
	tests := []struct {
		name string
		dt   *DateTime
		want time.Time
	}{
		{
			"general",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.UTC)},
			time.Date(2024, 9, 11, 10, 0, 0, 0, time.UTC),
		},
		{
			"different location",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.FixedZone("CST", 8*3600))},
			time.Date(2024, 9, 11, 10, 0, 0, 0, time.FixedZone("CST", 8*3600)),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.dt.BeginOfHour(); !got.Equal(tt.want) {
				t.Errorf("DateTime.BeginOfHour() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_EndOfHour(t *testing.T) {
	tests := []struct {
		name string
		dt   *DateTime
		want time.Time
	}{
		{
			"general",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.UTC)},
			time.Date(2024, 9, 11, 10, 59, 59, int(time.Second-time.Nanosecond), time.UTC),
		},
		{
			"different location",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.FixedZone("CST", 8*3600))},
			time.Date(2024, 9, 11, 10, 59, 59, int(time.Second-time.Nanosecond), time.FixedZone("CST", 8*3600)),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.dt.EndOfHour(); !got.Equal(tt.want) {
				t.Errorf("DateTime.EndOfHour() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_BeginOfDay(t *testing.T) {
	tests := []struct {
		name string
		dt   *DateTime
		want time.Time
	}{
		{
			"general",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.UTC)},
			time.Date(2024, 9, 11, 0, 0, 0, 0, time.UTC),
		},
		{
			"different location",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.FixedZone("CST", 8*3600))},
			time.Date(2024, 9, 11, 0, 0, 0, 0, time.FixedZone("CST", 8*3600)),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.dt.BeginOfDay(); !got.Equal(tt.want) {
				t.Errorf("DateTime.BeginOfDay() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_EndOfDay(t *testing.T) {
	tests := []struct {
		name string
		dt   *DateTime
		want time.Time
	}{
		{
			"general",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.UTC)},
			time.Date(2024, 9, 11, 23, 59, 59, int(time.Second-time.Nanosecond), time.UTC),
		},
		{
			"different location",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.FixedZone("CST", 8*3600))},
			time.Date(2024, 9, 11, 23, 59, 59, int(time.Second-time.Nanosecond), time.FixedZone("CST", 8*3600)),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.dt.EndOfDay(); !got.Equal(tt.want) {
				t.Errorf("DateTime.EndOfDay() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_BeginOfWeek(t *testing.T) {
	tests := []struct {
		name     string
		dt       *DateTime
		begFrom  time.Weekday
		want     time.Time
		wantWeek string
	}{
		{
			"general",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.UTC)},
			time.Sunday,
			time.Date(2024, 9, 8, 0, 0, 0, 0, time.UTC),
			"Sunday",
		},
		{
			"different location",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.FixedZone("CST", 8*3600))},
			time.Sunday,
			time.Date(2024, 9, 8, 0, 0, 0, 0, time.FixedZone("CST", 8*3600)),
			"Sunday",
		},
		{
			"begin from Monday",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.UTC)},
			time.Monday,
			time.Date(2024, 9, 9, 0, 0, 0, 0, time.UTC),
			"Monday",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := tt.dt.BeginOfWeek(tt.begFrom)
			if !got.Equal(tt.want) {
				t.Errorf("DateTime.BeginOfWeek() = %v, want %v", got, tt.want)
			}
			if got.Weekday().String() != tt.wantWeek {
				t.Errorf("DateTime.BeginOfWeek() = %v, want %v", got.Weekday().String(), tt.wantWeek)
			}
		})
	}
}

func TestDateTime_EndOfWeek(t *testing.T) {
	tests := []struct {
		name     string
		dt       *DateTime
		endWith  time.Weekday
		want     time.Time
		wantWeek string
	}{
		{
			"general",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.UTC)},
			time.Saturday,
			time.Date(2024, 9, 14, 23, 59, 59, int(time.Second-time.Nanosecond), time.UTC),
			"Saturday",
		},
		{
			"different location",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.FixedZone("CST", 8*3600))},
			time.Saturday,
			time.Date(2024, 9, 14, 23, 59, 59, int(time.Second-time.Nanosecond), time.FixedZone("CST", 8*3600)),
			"Saturday",
		},
		{
			"end with Friday",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.UTC)},
			time.Friday,
			time.Date(2024, 9, 13, 23, 59, 59, int(time.Second-time.Nanosecond), time.UTC),
			"Friday",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := tt.dt.EndOfWeek(tt.endWith)
			if !got.Equal(tt.want) {
				t.Errorf("DateTime.EndOfWeek() = %v, want %v", got, tt.want)
			}
			if got.Weekday().String() != tt.wantWeek {
				t.Errorf("DateTime.EndOfWeek() = %v, want %v", got.Weekday().String(), tt.wantWeek)
			}
		})
	}
}

func TestDateTime_BeginOfMonth(t *testing.T) {
	tests := []struct {
		name string
		dt   *DateTime
		want time.Time
	}{
		{
			"general",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.UTC)},
			time.Date(2024, 9, 1, 0, 0, 0, 0, time.UTC),
		},
		{
			"different location",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.FixedZone("CST", 8*3600))},
			time.Date(2024, 9, 1, 0, 0, 0, 0, time.FixedZone("CST", 8*3600)),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.dt.BeginOfMonth(); !got.Equal(tt.want) {
				t.Errorf("DateTime.BeginOfMonth() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_EndOfMonth(t *testing.T) {
	tests := []struct {
		name string
		dt   *DateTime
		want time.Time
	}{
		{
			"general",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.UTC)},
			time.Date(2024, 9, 30, 23, 59, 59, int(time.Second-time.Nanosecond), time.UTC),
		},
		{
			"different location",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.FixedZone("CST", 8*3600))},
			time.Date(2024, 9, 30, 23, 59, 59, int(time.Second-time.Nanosecond), time.FixedZone("CST", 8*3600)),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.dt.EndOfMonth(); !got.Equal(tt.want) {
				t.Errorf("DateTime.EndOfMonth() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_BeginOfYear(t *testing.T) {
	tests := []struct {
		name string
		dt   *DateTime
		want time.Time
	}{
		{
			"general",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.UTC)},
			time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC),
		},
		{
			"different location",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.FixedZone("CST", 8*3600))},
			time.Date(2024, 1, 1, 0, 0, 0, 0, time.FixedZone("CST", 8*3600)),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.dt.BeginOfYear(); !got.Equal(tt.want) {
				t.Errorf("DateTime.BeginOfYear() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_EndOfYear(t *testing.T) {
	tests := []struct {
		name string
		dt   *DateTime
		want time.Time
	}{
		{
			"general",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.UTC)},
			time.Date(2024, 12, 31, 23, 59, 59, int(time.Second-time.Nanosecond), time.UTC),
		},
		{
			"different location",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.FixedZone("CST", 8*3600))},
			time.Date(2024, 12, 31, 23, 59, 59, int(time.Second-time.Nanosecond), time.FixedZone("CST", 8*3600)),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.dt.EndOfYear(); !got.Equal(tt.want) {
				t.Errorf("DateTime.EndOfYear() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_DayOfYear(t *testing.T) {
	tests := []struct {
		name string
		dt   *DateTime
		want int
	}{
		{
			"general",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.UTC)},
			254,
		},
		{
			"different location",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.FixedZone("CST", 8*3600))},
			254,
		},
		{
			"first day of year",
			&DateTime{tm: time.Date(2024, 1, 1, 10, 23, 45, 123456789, time.UTC)},
			0,
		},
		{
			"last day of year",
			&DateTime{tm: time.Date(2024, 12, 31, 10, 23, 45, 123456789, time.UTC)},
			365,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.dt.DayOfYear(); got != tt.want {
				t.Errorf("DateTime.DayOfYear() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_Weekend(t *testing.T) {
	tests := []struct {
		name string
		dt   *DateTime
		want bool
	}{
		{
			"Saturday",
			&DateTime{tm: time.Date(2024, 9, 14, 10, 23, 45, 123456789, time.UTC)},
			true,
		},
		{
			"Sunday",
			&DateTime{tm: time.Date(2024, 9, 15, 10, 23, 45, 123456789, time.UTC)},
			true,
		},
		{
			"Monday",
			&DateTime{tm: time.Date(2024, 9, 16, 10, 23, 45, 123456789, time.UTC)},
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.dt.Weekend(); got != tt.want {
				t.Errorf("DateTime.Weekend() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDateTime_IsLeapYear(t *testing.T) {
	tests := []struct {
		name string
		dt   *DateTime
		want bool
	}{
		{
			"leap year",
			&DateTime{tm: time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.UTC)},
			true,
		},
		{
			"not leap year",
			&DateTime{tm: time.Date(2023, 9, 11, 10, 23, 45, 123456789, time.UTC)},
			false,
		},
		{
			"leap year century",
			&DateTime{tm: time.Date(2000, 9, 11, 10, 23, 45, 123456789, time.UTC)},
			true,
		},
		{
			"not leap year century",
			&DateTime{tm: time.Date(1900, 9, 11, 10, 23, 45, 123456789, time.UTC)},
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.dt.IsLeapYear(); got != tt.want {
				t.Errorf("DateTime.IsLeapYear() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestBetweenSeconds(t *testing.T) {
	t1 := time.Date(2024, 9, 11, 10, 23, 45, 123456789, time.UTC)
	t2 := time.Date(2024, 9, 11, 11, 24, 46, 123456789, time.UTC)
	want := int64(3600 + 60 + 1)
	if got := BetweenSeconds(t1, t2); got != want {
		t.Errorf("BetweenSeconds() = %v, want %v", got, want)
	}
}
